# 数据库-MySQL





#### 事务的四大特性（ACID）

1、原子性：确保事务的执行要么全部成功、要么全部失败回滚，不存在部分成功的情况

2、一致性：事务在执行前后从一个一致性状态转向另一个一致性状态

3、隔离性：多个事务并发执行时，每个事务应当被隔离开，互相不影响

4、持久性：一旦事务被提交，他对数据库的改变就是永久性的，即使在系统故障或崩溃后也能保持



#### 数据库的事务隔离级别

脏读：一个事务读取了另一个事务尚未提交的数据，但如果该事务回滚，则读到的数据是无效的

不可重复读：同一事务中，多次读取相同数据，结果不一致，因为其他事务修改了数据并提交

幻读：同一事务中，两次执行 select 语句，第二次读取时发现多或少了几行数据（因为其他事务插入/删除了数据）

1、读未提交（日志系统）：

允许一个事务读取另一个事务尚未提交的数据修改

最低的隔离级别，存在脏读，不可重复读和幻读问题

2、读已提交（Oracle）：

一个事务只能读取已经提交的数据

存在不可重复读和幻读问题

3、可重复读（MySQL）：

事务执行期间，多次读取同一数据会得到相同的结果，在事务开始和结束之间，其他事务的修改不可见

存在幻读问题

4、序列化（金融系统）：

最高的隔离级别，确保事务的执行与串行执行的结果相同，不存在脏读、不可重复读、幻读



#### 为什么dMySQL使用B+树

什么是B+树？

一种平衡的多路搜索树，所有数据都存储在叶子节点，其余节点仅存储索引（键值），叶子节点仅通过指针链接，通过插入分裂、删除合并保持平衡

为什么使用B+树？

在数据量相同的情况下，B+树的非叶子节点可以存放更多的索引，整体高度更小，查询底层节点的I/O更少

B+树有大量冗余节点，使得B+树的插入、删除效率更高，不会产生复杂的树形变化

B+树的叶子节点使用链表连接，有利于范围查询



#### 执行一条select语句的过程

连接器：与客户端建立连接，获取权限，维持和管理连接

解析SQL：通过解析器对查询语句进行词法分析、语法分析，然后构建语法树

执行SQL：三个阶段

​	预处理阶段：检查表或字段是否存在，将select ※中的"※"符号扩展为表上的所有列

​	优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划

​	执行阶段：根据执行计划执行SQL查询语句，从引擎读取记录，返回客户端



#### 关系范式

第一范式：每一个字段的值必须是原子的（不可再分割），列中不能存储多个值

第二范式：在第一范式的基础上，所有字段的值必须依赖主键的所有字段

第三范式：在第二范式的基础上，所有字段的值必须只依赖主键，不能通过其他列间接依赖

BC范式：在第三范式的基础上，主键中的属性不能依赖于其他主键中的属性



#### 数据库表的优化方式

1、合理分表分表方式，对较大的表拆分成多个子表

2、在经常查询的列上建立索引

3、避免使用select*

4、选择合适的数据类型：尽量使用tinyint,smallint,unsigned；时间类型使用timestamp而不是datetime



#### MongoDB与MySQL的区别

数据模型：

MySQL是关系型数据库，以表格形式存储

MongoDB是文档型数据库，以binary JSON形式存储

模式设计：

MySQL有模式，表结构需要在设计时明确定义，包括字段名、数据类型

MongoDB无模式，文档可以根据需要动态添加字段，没有固定的表结构

适用场景：

MySQL适用于处理结构化数据，支持事务处理和复杂的查询

MongoDB适用于处理大量非结构化或者半结构化的数据

扩展性：

MySQL使用主从复制和垂直分区来实现扩展性

MongoDB有较好的横向扩展性，可以通过分片在多台机器上分布数据



#### 慢查询

数据库查询时间超过指定时间

原因：

· 语句复杂，涉及多个表、连接、子查询

· 查询数量大

· 缺少索引

· 并发冲突：多个查询同时访问相同资源

· 硬件资源不足：服务器负载过高

优化：

· 运行语句，找到慢查询的SQL

· 查询区分度高的字段

· 使用explain命令对SQL进行分析

· 使用order by limit形式的SQL语句，让排序的表先查

· 建立索引



### 锁



#### 锁的种类

1、全局锁

将整个数据库加锁，使用场景：全库逻辑备份，将整个库select出来存成文本

命令：

```mysql
flush tables with read lock;
```

使用后数据的增删改、表结构的建立修改等都会被阻塞

解锁：

```mysql
unlock tables;
```



2、表级锁

（1）表锁

锁住整张表

```mysql
lock tables ... read/write; 
```

lock tables除了会限制其他线程的读写外，也限定了本线程接下来的操作对象

（2）元数据锁（MDL）

不需要显式使用，访问表时会被自动加上

MDL的作用：保证读写的正确性

当对一个表做增删改查操作时，加入MDL读锁

当对一个表的结构做变更操作时，加入MDL写锁

读锁之间不互斥，读写锁之间、写锁之间互斥，用于保证变更表结构操作的安全性

事务中的MDL锁在语句执行开始时申请，结束后并不马上释放，直到整个事务提交后再释放（可能导致死锁）

（3）意向锁

用于表示一个事务在未来可能对某些资源进行锁定

· 意向共享锁表示事务打算在资源上获得共享锁，其他事务可以继续获得共享锁，但不能获得排他锁

· 意向排他锁表示事务打算在资源上获得排他锁

在对行上共享锁前要对整个表上意向共享锁，行上独占锁前要对整个表上意向独占锁

意向锁的目的是为了快速判断表中是否有记录被加锁

（4）auto-inc锁

表中的主键通常设为自增，在插入数据时不指定主键的值。在插入数据时会加一个表级别的auto-inc锁，等语句执行完后再释放，从而保证主键的值连续递增

缺陷：大量数据插入影响性能，其他事务的插入被阻塞

改进：InnoDB引擎提供一种轻量级的锁实现自增，插入字段时会为主键上一个轻量级的锁，为主键赋自增值后释放锁，不必等待整个插入语句执行完

3、行级锁

行级锁在需要时才加上，事务结束后才释放（两阶段锁协议）

两个原则：

1、加锁的基本单位是next-key lock（前开后闭）

2、查找过程中访问到的对象才会加锁

两个优化：

1、索引上的等值查询，给唯一索引加锁的时候next-key lock退化为行锁

2、索引上的等值查询，向右遍历且最后一个值不满足条件时next-key lock退化为间隙锁



#### 排他锁和共享锁是什么，有什么区别？

排他锁（写锁/独占锁）：锁定后其他事务无法查询或修改，进行增删改操作时，数据库自动使用排他锁

共享锁（读锁）：锁定后可被其他事务读取，但不能修改

区别：

排他锁是独占的，一次只能由一个事务持有，共享锁是非独占的，允许多个事务同时持有相同资源的共享锁

排他锁用于写操作，共享锁用于读操作



#### MySQL行级锁有哪些，作用是什么？

record lock：记录锁，仅把一条记录锁上，分为排他锁和共享锁

gap lock：间隙锁，锁定一个范围，不包含记录本身。只存在与可重复读隔离级别，目的为了解决该级别下的幻读现象

next-key lock：临键锁，锁定一个范围，包括记录本身。既能保护该记录，也能阻止其他事务插入新纪录到保护记录前面的间隙中



#### 乐观锁和悲观锁

1、乐观锁：认为对同一个数据的并发操作不会总发生，不用每次对数据上锁，不采用数据库自身的锁机制，而使用程序来实现。程序上可以使用版本号或时间戳机制实现

2、悲观锁：认为对同一数据的并发操作属于大概率事件，通过数据库自身的锁机制来实现，保证数据操作的排他性

3、适用场景：

乐观锁适用于读操作多的场景，优点在于程序实现，不存在死锁问题

悲观锁适用于写操作的的场景，有效防止读-写冲突、写-写冲突。但是加锁时间较长，并发性不好

| 项目         | 悲观锁                     | 乐观锁                       |
| ------------ | -------------------------- | ---------------------------- |
| 并发冲突假设 | 经常发生                   | 很少发生                     |
| 加锁方式     | 直接加锁（阻塞其他线程）   | 不加锁，更新时判断版本       |
| 性能开销     | 高                         | 低                           |
| 适用场景     | 写多、冲突频繁             | 读多写少、冲突概率低         |
| 实现复杂度   | 低（数据库或同步工具支持） | 高（需手动维护版本号等机制） |
| 失败处理     | 等待或阻塞                 | 通常需重试机制               |



