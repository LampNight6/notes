# 数据库-MySQL





#### 事务的四大特性（ACID）

1、原子性：确保事务的执行要么全部成功、要么全部失败回滚，不存在部分成功的情况

2、一致性：事务在执行前后从一个一致性状态转向另一个一致性状态

3、隔离性：多个事务并发执行时，每个事务应当被隔离开，互相不影响

4、持久性：一旦事务被提交，他对数据库的改变就是永久性的，即使在系统故障或崩溃后也能保持



#### 数据库的事务隔离级别

脏读：一个事务读取了另一个事务尚未提交的数据，但如果该事务回滚，则读到的数据是无效的

不可重复读：同一事务中，多次读取相同数据，结果不一致，因为其他事务修改了数据并提交

幻读：同一事务中，两次执行 select 语句，第二次读取时发现多或少了几行数据（因为其他事务插入/删除了数据）

1、读未提交（日志系统）：

允许一个事务读取另一个事务尚未提交的数据修改

最低的隔离级别，存在脏读，不可重复读和幻读问题

2、读已提交（Oracle）：

一个事务只能读取已经提交的数据

存在不可重复读和幻读问题

3、可重复读（MySQL）：

事务执行期间，多次读取同一数据会得到相同的结果，在事务开始和结束之间，其他事务的修改不可见

存在幻读问题

4、序列化（金融系统）：

最高的隔离级别，确保事务的执行与串行执行的结果相同，不存在脏读、不可重复读、幻读





#### 执行一条select语句的过程

连接器：与客户端建立连接，获取权限，维持和管理连接

解析SQL：通过解析器对查询语句进行词法分析、语法分析，然后构建语法树

执行SQL：三个阶段

​	预处理阶段：检查表或字段是否存在，将select ※中的"※"符号扩展为表上的所有列

​	优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划

​	执行阶段：根据执行计划执行SQL查询语句，从引擎读取记录，返回客户端



#### 关系范式

第一范式：每一个字段的值必须是原子的（不可再分割），列中不能存储多个值

第二范式：在第一范式的基础上，所有字段的值必须依赖主键的所有字段

第三范式：在第二范式的基础上，所有字段的值必须只依赖主键，不能通过其他列间接依赖

BC范式：在第三范式的基础上，主键中的属性不能依赖于其他主键中的属性



#### 数据库表的优化方式

1、合理分表分表方式，对较大的表拆分成多个子表

2、在经常查询的列上建立索引

3、避免使用select*

4、选择合适的数据类型：尽量使用tinyint,smallint,unsigned；时间类型使用timestamp而不是datetime



#### MongoDB与MySQL的区别

数据模型：

MySQL是关系型数据库，以表格形式存储

MongoDB是文档型数据库，以binary JSON形式存储

模式设计：

MySQL有模式，表结构需要在设计时明确定义，包括字段名、数据类型

MongoDB无模式，文档可以根据需要动态添加字段，没有固定的表结构

适用场景：

MySQL适用于处理结构化数据，支持事务处理和复杂的查询

MongoDB适用于处理大量非结构化或者半结构化的数据

扩展性：

MySQL使用主从复制和垂直分区来实现扩展性

MongoDB有较好的横向扩展性，可以通过分片在多台机器上分布数据



#### 慢查询

数据库查询时间超过指定时间

原因：

· 语句复杂，涉及多个表、连接、子查询

· 查询数量大

· 缺少索引

· 并发冲突：多个查询同时访问相同资源

· 硬件资源不足：服务器负载过高

优化：

· 运行语句，找到慢查询的SQL

· 查询区分度高的字段

· 使用explain命令对SQL进行分析

· 使用order by limit形式的SQL语句，让排序的表先查

· 建立索引



### 锁



#### 锁的种类

1、全局锁

将整个数据库加锁，使用场景：全库逻辑备份，将整个库select出来存成文本

命令：

```mysql
flush tables with read lock;
```

使用后数据的增删改、表结构的建立修改等都会被阻塞

解锁：

```mysql
unlock tables;
```



2、表级锁

（1）表锁

锁住整张表

```mysql
lock tables ... read/write; 
```

lock tables除了会限制其他线程的读写外，也限定了本线程接下来的操作对象

（2）元数据锁（MDL）

不需要显式使用，访问表时会被自动加上

MDL的作用：保证读写的正确性

当对一个表做增删改查操作时，加入MDL读锁

当对一个表的结构做变更操作时，加入MDL写锁

读锁之间不互斥，读写锁之间、写锁之间互斥，用于保证变更表结构操作的安全性

事务中的MDL锁在语句执行开始时申请，结束后并不马上释放，直到整个事务提交后再释放（可能导致死锁）

（3）意向锁

用于表示一个事务在未来可能对某些资源进行锁定

· 意向共享锁表示事务打算在资源上获得共享锁，其他事务可以继续获得共享锁，但不能获得排他锁

· 意向排他锁表示事务打算在资源上获得排他锁

在对行上共享锁前要对整个表上意向共享锁，行上独占锁前要对整个表上意向独占锁

意向锁的目的是为了快速判断表中是否有记录被加锁

（4）auto-inc锁

表中的主键通常设为自增，在插入数据时不指定主键的值。在插入数据时会加一个表级别的auto-inc锁，等语句执行完后再释放，从而保证主键的值连续递增

缺陷：大量数据插入影响性能，其他事务的插入被阻塞

改进：InnoDB引擎提供一种轻量级的锁实现自增，插入字段时会为主键上一个轻量级的锁，为主键赋自增值后释放锁，不必等待整个插入语句执行完

3、行级锁

行级锁在需要时才加上，事务结束后才释放（两阶段锁协议）

两个原则：

1、加锁的基本单位是next-key lock（前开后闭）

2、查找过程中访问到的对象才会加锁

两个优化：

1、索引上的等值查询，给唯一索引加锁的时候next-key lock退化为行锁

2、索引上的等值查询，向右遍历且最后一个值不满足条件时next-key lock退化为间隙锁



#### 排他锁和共享锁是什么，有什么区别？

排他锁（写锁/独占锁）：锁定后其他事务无法查询或修改，进行增删改操作时，数据库自动使用排他锁

共享锁（读锁）：锁定后可被其他事务读取，但不能修改

区别：

排他锁是独占的，一次只能由一个事务持有，共享锁是非独占的，允许多个事务同时持有相同资源的共享锁

排他锁用于写操作，共享锁用于读操作



#### MySQL行级锁有哪些，作用是什么？

record lock：记录锁，仅把一条记录锁上，分为排他锁和共享锁

gap lock：间隙锁，锁定一个范围，不包含记录本身。只存在与可重复读隔离级别，目的为了解决该级别下的幻读现象

next-key lock：临键锁，锁定一个范围，包括记录本身。既能保护该记录，也能阻止其他事务插入新纪录到保护记录前面的间隙中



#### 乐观锁和悲观锁

1、乐观锁：认为对同一个数据的并发操作不会总发生，不用每次对数据上锁，不采用数据库自身的锁机制，而使用程序来实现。程序上可以使用版本号或时间戳机制实现

2、悲观锁：认为对同一数据的并发操作属于大概率事件，通过数据库自身的锁机制来实现，保证数据操作的排他性

3、适用场景：

乐观锁适用于读操作多的场景，优点在于程序实现，不存在死锁问题

悲观锁适用于写操作的的场景，有效防止读-写冲突、写-写冲突。但是加锁时间较长，并发性不好

| 项目         | 悲观锁                     | 乐观锁                       |
| ------------ | -------------------------- | ---------------------------- |
| 并发冲突假设 | 经常发生                   | 很少发生                     |
| 加锁方式     | 直接加锁（阻塞其他线程）   | 不加锁，更新时判断版本       |
| 性能开销     | 高                         | 低                           |
| 适用场景     | 写多、冲突频繁             | 读多写少、冲突概率低         |
| 实现复杂度   | 低（数据库或同步工具支持） | 高（需手动维护版本号等机制） |
| 失败处理     | 等待或阻塞                 | 通常需重试机制               |





### 索引



#### 什么是索引

索引是数据库为了加快数据检索额外维护的一种数据结构，通过建立数据键值和数据地址之间的映射，减少查询及IO开销



#### 索引的基本概念

键值（Key）：索引所依据的列或列组合的值，比如用户表中的 `user_id`、`name` 等。

指针（Pointer）：指向实际数据行在磁盘或内存中的存储位置。

索引条目（Entry）：一条记录由“键值 + 指针”组成。

聚集索引（Clustered Index）：表数据按索引顺序物理存储，一个表只能有一个聚集索引。

非聚集索引（Non‑clustered Index）：索引与表数据分开存放，通过指针关联，可以有多个。



#### 索引的种类

| 对比项           | **B+树索引**                     | **哈希索引**                     | **位图索引**                   |
| ---------------- | -------------------------------- | -------------------------------- | ------------------------------ |
| **结构原理**     | 多叉平衡树，叶节点按键值有序连接 | 哈希表，键经过哈希函数映射到桶   | 为每个取值创建一位向量（位图） |
| **查询效率**     | O(log n)                         | O(1)（均摊）                     | O(1) + 位运算                  |
| **支持范围查询** | ✅ 支持（连续的叶节点）           | ❌ 不支持                         | ✅ 支持位图扫描                 |
| **支持排序**     | ✅（天然有序）                    | ❌                                | ✅（可排序）                    |
| **支持等值查询** | ✅                                | ✅（最快）                        | ✅（需做位图与运算）            |
| **适用字段类型** | 任意字段                         | 高基数字段                       | 低基数字段（性别、状态等）     |
| **空间占用**     | 中等（树结构）                   | 中等（哈希表）                   | 高（每个取值需一位向量）       |
| **更新开销**     | 中（可能分裂或合并节点）         | 中（可能重哈希）                 | 高（需修改多个位图）           |
| **典型场景**     | 通用场景、主键/外键/范围查询等   | 查询等值主键或唯一键             | 数据仓库中统计、多条件组合过滤 |
| **是否常用**     | ✅ 数据库最常用索引               | 🚫 一般仅在特定引擎如Memory中支持 | 🚫 特殊用途，如分析型数据库     |



#### 为什么MySQL使用B+树

什么是B+树？

一种平衡的多路搜索树，所有数据都存储在叶子节点，其余节点仅存储索引（键值），叶子节点仅通过指针链接，通过插入分裂、删除合并保持平衡

为什么使用B+树？

在数据量相同的情况下，B+树的非叶子节点可以存放更多的索引，整体高度更小，查询底层节点的I/O更少

B+树有大量冗余节点，使得B+树的插入、删除效率更高，不会产生复杂的树形变化

B+树的叶子节点使用链表连接，有利于范围查询



#### 索引和缓存的区别

| 对比维度         | **索引（Index）**                                        | **缓存（Cache）**                             |
| ---------------- | -------------------------------------------------------- | --------------------------------------------- |
| **本质**         | 加速**定位数据的位置**的辅助数据结构                     | 临时存储**常用数据的副本**，加速直接访问      |
| **作用对象**     | 提供“**在哪**”的信息，帮助快速查找原始数据               | 提供“**是什么**”的直接数据，避免重复计算/访问 |
| **数据来源**     | 来自数据库表结构和记录位置                               | 来自历史查询、计算、API请求结果等             |
| **数据内容**     | 存储键值 + 数据位置映射                                  | 存储完整的数据副本（键值 + 内容）             |
| **存储位置**     | 通常在磁盘或数据库内存结构中                             | 通常在内存中（如 Redis、本地变量、对象池等）  |
| **数据结构**     | B+树、哈希表、位图等                                     | 哈希表（如 LRU Cache）、队列、内存池等        |
| **是否持久化**   | ✅ 是，数据库负责维护                                     | ❌ 一般不持久化（如 Redis 可选持久化）         |
| **更新维护**     | 自动与数据一致性维护（如插入/更新时自动调整）            | 需手动管理更新或失效（如 Cache Invalidate）   |
| **适用场景**     | 数据库层加速查找、排序、范围扫描                         | 应用层或系统层避免重复查询、计算、远程请求    |
| **典型操作**     | `WHERE id = ?`、`ORDER BY`、`BETWEEN`                    | `GET key`（如 Redis）、本地缓存池查找         |
| **能否替代彼此** | ❌ 不能返回数据本身，只能帮助定位                         | ❌ 不参与查找，只返回结果                      |
| **协同使用方式** | 查询时先查缓存，缓存未命中再用索引查库，并将结果加入缓存 | 缓存命中可跳过索引查库，降低数据库负载        |



