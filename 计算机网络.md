# 计算机网络

## OSI七层模型 vs. TCP/IP四层模型 vs. 五层网络体系结构

| OSI七层模型                | TCP/IP四层模型                  | 五层网络体系结构           | 主要功能描述                                                 |
| -------------------------- | ------------------------------- | -------------------------- | ------------------------------------------------------------ |
| **应用层** (Application)   | **应用层** (Application)        | **应用层** (Application)   | 提供用户接口，如HTTP、FTP、SMTP、DNS等协议                   |
| **表示层** (Presentation)  | N/A                             | N/A                        | 处理数据格式、加密解密、压缩等                               |
| **会话层** (Session)       | N/A                             | N/A                        | 负责会话控制，如对话建立、管理和终止                         |
| **传输层** (Transport)     | **传输层** (Transport)          | **传输层** (Transport)     | 端到端通信，提供可靠或不可靠的数据传输（如TCP、UDP）         |
| **网络层** (Network)       | **网络层** (Internet)           | **网络层** (Network)       | 负责数据的路由和转发，传输单位是数据报，常见协议：ICMP、ARP、IP |
| **数据链路层** (Data Link) | **网络接口层** (Network Access) | **数据链路层** (Data Link) | 将比特组合成字节进而合成”帧“，使用MAC地址                    |
| **物理层** (Physical)      | **网络接口层** (Network Access) | **物理层** (Physical)      | 传输比特流（bit）                                            |



### ARP

地址解析协议，用于将IP地址转换为MAC地址，公网中只能使用IP地址，局域网中只能使用MAC地址



#### ARP的工作流程

1. 主机 A 想与 IP 为 192.168.1.100 的主机通信。
2. A 查询自己的 ARP 缓存，没有对应的 MAC 地址。
3. A 通过广播方式发送 ARP 请求：谁是 192.168.1.100？
4. 目标主机收到请求后，发送 ARP 回复，包含自己的 MAC 地址。
5. A 接收到后更新 ARP 表并开始通信。



#### ARP使用的是广播还是单播

ARP请求使用的是广播

ARP相应使用的是单播



#### ARP缓存

ARP使用缓存表存储IP地址与MAC地址的映射，缓存时间一般是60秒，过期重新发送请求

查看方式：arp -n(Linux)  arp - a(Windows)



#### 动态与静态ARP

| 类型            | 特点                                   | 示例命令查看                           |
| --------------- | -------------------------------------- | -------------------------------------- |
| 动态（Dynamic） | 系统自动记录，带有过期时间（60~120秒） | `arp -a`                               |
| 静态（Static）  | 人工设置，永久有效，不被覆盖           | `arp -s 192.168.1.1 00-11-22-33-44-55` |



#### ARP攻击，防范手段

攻击者伪造ARP响应，将自己的MAC地址绑定到局域网内目标主机或网关的IP地址上，从而实现窃听、篡改、拦截

| 类型                   | 说明                                     |
| ---------------------- | ---------------------------------------- |
| **中间人攻击（MITM）** | 拦截双向通信，窃听或篡改数据             |
| **DoS 攻击**           | 向主机伪造错误的 MAC，导致其无法通信     |
| **Session 劫持**       | 劫持认证后的会话，如 cookie/session 信息 |
| **DNS 劫持**           | 改写 DNS 请求指向攻击者控制的服务器      |



如何防御APR攻击：

| 方法                                         | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| 静态 ARP 表                                  | 固定 IP 与 MAC 的映射，不信任动态 ARP 响应。适用于小规模部署。 |
| DHCP Snooping + ARP Inspection（交换机功能） | 高级网络设备可以检测伪造的 ARP 包，拒绝非法响应。            |
| 使用 HTTPS                                   | 即使发生中间人攻击，也难以解密通信内容。                     |
| 局域网隔离                                   | 分 VLAN，控制广播范围，防止跨网段攻击                        |
| 工具监测                                     | `arpwatch`、IDS/IPS 等监控网络异常                           |



#### 2. 如果你写了一个服务，客户端连接不上，`ping` 不通，你会怎么排查？（侧重网络）

- 检查客户端是否获取了正确的 IP。
- 查看 `arp -a` 中是否有目标主机的 MAC。
- 用 `arping` 工具试试直接发 ARP 包看是否能响应。
- 如果没有回应，可能是目标主机网络断开、物理连接异常或防火墙设置不允许 ARP 请求响应。



### ICMP

ICMP 是一个网络层协议，用于传递控制消息、错误报告和网络诊断信息。它不是用来传输数据，而是为了协助 IP 协议处理异常情况，比如目标不可达、TTL 超时等



#### ping命令原理

ping 命令通过发送 ICMP 的 Echo Request（类型8）报文，目标主机收到后回复 Echo Reply（类型0）。

通过是否能收到回复以及 RTT 时间，可以判断目标主机是否在线、响应是否及时。



#### traceroute命令原理

traceroute 通过发送 TTL 从 1 开始递增的数据包，每一跳 TTL 到达 0 的路由器都会返回 ICMP 的 Time Exceeded 报文（类型11）。这样可以依次探测出数据包经过的路由路径。
 区别在于：

- ping 是判断是否可达；
- traceroute 是追踪路径每一跳的路由器地址。



####  ICMP 是可靠传输吗？为什么 ping 会丢包？

 ICMP 是不可靠协议，没有重传机制。网络中的拥塞、丢包、防火墙限制等都可能导致 ping 的 Echo Request 或 Echo Reply 丢失，因此 ping 并不能保证 100% 成功，它只是网络状态的参考工具。



#### 后端服务部署后，用户反馈访问慢或超时，你如何排查？ICMP 在这里能起到什么作用？

- 用 ping 检查用户 → 服务器的连通性；
- 用 traceroute 判断是否存在网络跳数过多、某一段 RTT 异常；
- 如果 ICMP 报文被防火墙拦截，也说明网络策略设置不合理；
- 所以 ICMP 是网络延迟或丢包问题的第一步诊断工具。



### URL

#### 从输入URL到页面展示发生了什么

1、URL输入

2、域名解析，通过域名系统（DNS)解析为IP地址

3、建立连接，使用TCP协议进行三次握手

4、发送请求，发送HTTP请求，包括路径、方法（get，post）、头部信息

5、服务器处理，处理请求并返回响应

6、接收响应，包含HTTP状态码、头部信息、页面内容

7、页面解析，构建文档对象模型（DOM）和渲染树，确定页面的结构、样式、行为

8、页面渲染，将页面内容绘制到屏幕上

9、执行js，添加交互和动态行为

10、加载资源，加载外部资源

11、完成页面加载



#### URL和URI的区别

URI：统一资源标识符，用于标记任何互联网上的资源

URL：一种特殊的URI，标识资源并且提供资源位置信息，URL由以下几部分组成

1、协议

2、域名/IP地址

3、端口号

4、路径

5、查询参数

6、片段标识

以下是⼀个示例URL：https://www.example.com:8080/path/resource?param=value#section 在这个示例URL中，协议是HTTPS，域名是www.example.com ，端⼝号是8080，路径是/path/resource，查询参 数是param=value，⽚段标识是section。





### HTTP

#### HTTP请求报文

**通用头部字段**：

cache-control：指定缓存策略

connection：控制连接的行为

date：指定日期和时间

**请求行**：请求方法（get、post、put...）+URL+协议版本号（http版本号）

**请求头**：请求附加信息

host：主机名、端口号

User-Agent：客户端的用户代理

accept：客户端可以接收响应的MIME类型	ps：常见MIME类型：text,image,audio,video,application

content-type：请求主体的MIME类型

authorization：身份验证的凭据

**请求体**：承载具体请求参数的数据



#### HTTP响应报文

**状态行**：HTTP协议版本、状态码、状态消息

**响应头**：

content-type：相应主体的MIME类型

contene-length：响应主体长度

server：服务器信息

location：重定向时指定新的资源位置

set-cookie：在响应中设置cookie

**空行**：分隔响应头和响应体

**响应主体**：服务器返回给客户端的实际内容，如html网页



#### 什么是TCP粘包、拆包问题，如何解决

TCP是一个面向字节流的协议，它不会维护消息的边界，而是将数据视为一个连续的字节流进行传输，会导致粘包和拆包问题。

**粘包**：多个小数据包合并到一起，导致数据边界混乱

**拆包**：一个完整的数据包被拆为多个小块，接收方需要多次接收才能拼凑出完整数据

**发生原因**：

Nagle算法，将多个小包合并成一个大包，提高传输效率

接受端按照操作系统的缓冲区接收数据，可能一次性读多个包，或一个包分多次读取

**解决方法**：

固定长度协议：不满指定长度时填充，适用于定长消息

特殊分隔符：如\r \n ，适用于文本协议

消息头+消息体：在数据包开头加上消息长度字段，根据长度读取完整数据，适用于变长数据

**UDP会有拆包粘包问题吗？**

不会。UDP是面向数据报的协议（保护消息边界），以数据报为单位进行传输。要么整个数据报接收，要么整个数据报丢弃。数据的具体分割、合并在IP层处理



#### HTTP请求方法

get：申请获取资源，不影响服务器

post：客户端向服务端发送数据，服务器动态创建、更新现有资源

head：仅要求返回头部信息，不返回实际资源

put：更新服务器上的资源或创建新资源

delete：请求删除指定资源

trace：测试，要求返回原始HTTP请求内容

patch：对资源部分更新

connect：代理服务器

options：获取服务器支持的HTTP方法列表

#### POST与GET方法的区别

参数传递：get参数写在URL中，数据量<2kb，只接受ASCLL字符；post参数写在请求体中，不限制数据量和字符类型

报文内容：post的参数在请求体中，请求体与请求头之间必须空行

安全和幂等：get是只读操作，因此是安全幂等的；post是提交或新增操作，因此是不安全也不幂等的	

ps：幂等的概念：多次执行相同的操作结果都相同

**缓存机制：**

get请求会被浏览器主动cache；post不会自动保留缓存，除非手动设置

get请求参数会被完整的保留在浏览器的历史记录里，post不会

get产生的URL可以保存为书签，post不行

get在浏览器回退时是无害的，post会重新提交数据

时间消耗：get产生一个TCP数据包，服务器响应200；post产生两个TCP数据包，先发送header，服务器响应100 continue，浏览器再发送data，服务器再响应200 ok

编码方式：get只能使用URL编码，post支持多种编码方式

#### HTTP状态码

1xx：提示信息，协议处理的中间状态

2xx：请求成功

3xx：请求重定向

4xx：请求错误

5xx：服务器错误



200：（成功）客户端请求成功

204：（无内容）服务器成功处理了请求，但是没有返回任何内容

206：（部分内容）服务器成功处理了部分get请求，但仅返回了部分请求资源。用于断点续传、流媒体播放、按需加载数据

301：（永久重定向）网页已经移动到新位置

302：（临时重定向）请求的资源还在，但是需要另一个URL访问

304：（未修改）自从上次请求后，网页从未修改，直接访问缓存

400：（语法错误）请求报文语法有误，服务器无法识别

401：（未授权）请求需要认证

403：（禁止）服务器拒绝请求

404：（未找到）找不到请求的网页

500：（服务器内部错误）服务器内部无法完成请求

503：（服务不可用）服务器无法使用、正忙， 一般是暂时状态



#### HTTP缓存类型

缓存解决的问题：减少网络传输、节约带宽、更快加载、减少服务器负载

**强制缓存：**

不与服务器通讯，直接判断是否命中，直接读取内存

设置一个强缓存时间，在此时间范围内直接访问内存

**协议缓存：**

依赖客户端与服务器的交互，客户端通过服务器的响应来判断资源是否发生变化，是否需要重新传输

协商缓存的头部字段：

ETag：通过文件计算出的hash值，在头部中的If-None-Match字段中携带上次的ETag值，服务器匹配后返回304

Last-Modified：资源的最后修改时间，在头部中的If-Modified-Since字段中携带上次的Last-Modified，服务器匹配后返回304



#### HTTP1.1特性

1、持久连接：只要客户端任意一端没有明确断开TCP连接，就一直保持连接

2、管线化：允许客户端在不等待前一个响应返回的情况下发送多个请求

3、新增put、delete、options、patch等新方法

4、新增24个错误状态响应码

5、新增缓存字段If-None-Match、If-Modified-Since

6、在请求头中引入range，允许只请求资源的某个部分，返回206

7、允许响应分块，利于传输大文件

8、新增host字段，使得一个服务器可用于创建多个web站点



#### HTTP2.0新特性

1、传输格式变化，完全采用二进制模式，健壮性提高

2、多路复用，一个请求对应一个ID，每个连接支持多个请求，提高效率

3、header压缩，通过encoder减小header大小，通讯双方缓存一份header字段表，避免header重复传输

4、服务端推送，把客户端所需要的资源随着index.html一起发送到客户端，省去客户端请求流程



#### HTTPS与HTTP的区别

HTTP是明文传输存在安全风险，HTTPS在TCP和HTTP网络层之间加入SSL/TLS安全协议，使报文安全传输

HTTPS在TCP三次握手后还需进行SSL/TLS握手

HTTP端口为80，HTTPS端口为443

HTTPS需要向权威数字机构（CA）申请证书，来保证服务器的可信身份



#### HTTPS完整过程

浏览器连接服务器，服务器返回 **数字证书**

浏览器验证证书是否合法（是否由受信 CA 签发）

双方通过 **非对称加密（公钥/私钥）** 交换密钥

建立对称加密通道，用于安全通信（因为对称加密效率高）

所有后续数据都经过加密传输



#### SSL/TLS

SSL：安全套接字

TLS：安全传输层协议

通过三种方式保证安全通信：

加密：防止信息泄露，保密性

身份验证：使用数字证书验证双方身份，保证可用性

数据完整性：使用消息摘要算法（hash），确保数据传输过程中未遭到篡改或损坏



#### HTTPS建立连接过程

1、客户端发送连接请求： 发送到443端口

2、服务器响应：发送一个CA证书给客户端，包括服务器公钥，证书的颁发者信息

3、客户端验证证书：验证签名、是否过期、是否匹配

4、客户端生成会话密钥：生成一个对称密钥

5、向服务器发送会话密钥：使用公钥加密对称密钥

6、服务器解密会话密钥：建立安全通信





#### DNS解析过程

1、先查询浏览器缓存中是否有该域名对应的IP地址

2、查询本机host文件

3、向本地DNS服务器发送一个DNS查询请求

4、查询本地DNS的缓存，本地DNS服务器向根DNS服务器发送查询请求，根DNS服务器返回对应的顶级域名服务器

5、本地DNS向顶级域名服务器发送查询请求，顶级域名服务器返回权威DNS服务器

6、本地DNS向权威DNS服务器发送查询请求，权威DNS服务器返回IP地址

7、本地DNS向浏览器返回IP地址，并缓存该解析结果

8、浏览器发起连接



#### 递归查询与迭代查询

递归查询：DNS客户端向上层DNS服务器发起查询请求，等待返回完整解析结果

迭代查询：DNS客户端向上层DNS服务器发起查询请求，根据返回的更高级服务器的地址发起查询，直至返回完整解析结果

递归查询适用于普通用户与客户端，迭代插叙适用于DNS服务器间通讯



### TCP和UDP

#### 区别

1、连接：

TCP是面向连接的，传输前需要三次握手建立连接

UDP不需要连接，直接发送数据包

2、服务形式

TCP是**一对一**的双向通信

UDP是**一对一，一对多，多对多**的通信，适用于多播和广播应用

3、可靠性

TCP保证数据可靠交付，拥有确认应答和重传机制，无重复、不丢失、按序

UDP尽可能交付，不保证可靠性

4、流量控制和拥塞控制

TCP拥有流量控制和拥塞控制，防止网络拥塞

UDP不进行控制，数据发送效率不受限制

5、首部开销

TCP首部通常为20字节：源端口、目的端口、序列号、确认号、窗口大小、校验和等，可能会更大

UDP首部固定为8字节：源端口、目的端口、包长度、校验和字段

6、传输方式

TCP基于字节流，没有边界，但是保证顺序和可靠性

UDP继承IP层特性，基于数据包，有边界，可能出现乱序和丢包

**理解为：TCP可以接受连续的字节流，在传输层主动分割、主动合并，UDP只接受数据报，只负责传输，由应用层分割合并**

7、分片方式

TCP在传输层分片与合并，丢包只需要重传对应的分片

UDP在网络层分片与合并，IP数据报中缺少分片的情况会丢弃整个数据报

8、使用场景

TCP适用于可靠传输，如文件传输、电子邮件、网页浏览

UDP适用于实时传输，如实时游戏，流媒体等



#### TCP如何确保可靠性

确保可靠性的方式：校验和、序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制

序列号和确认应答：TCP给每个发送的数据段分配一个序列号，使用确认机制（ACK）跟踪数据的传输和接收，确定重传的字段

超时和重传：使用超时机制检测数据包是否丢失，重传未收到确认的数据包

流量控制：使用滑动窗口机制确保发送方不会以高于接收方处理速度的速率发送，防止接收方缓冲区溢出

拥塞控制：动态调整发送速率以适应网络状况



#### 如何使用UDP实现可靠传输

为什么要实现可靠UDP？

在弱网环境下使用TCP延迟较高，影响体验

如何实现？

在应用层考虑实现超时重传、确认序列号

本端：在UDP数据报定义一个首部，包含确认序列号和时间戳。时间戳用于计算RTT（数据报传输往返时间），RTO（超时重传时间）。在收到对端确认后发送下一个数据报。若超时重传，则RTO翻倍。、

对端：根据序列号对数据报排序，丢弃重复的数据报。在数据报中添加确认数据返回。

已经实现的可靠UDP

RUDP 可靠数据报传输协议

RTP 实时传输协议



#### TCP重传机制

序号与确认号：每一个发送的报文都有一个唯一的序号，每一个接收的报文都有一个唯一的确认号

超时检测：为每一个发送的数据报文设置一个超时时间，未收到确认则重传

重传策略：只重传丢失的数据段

快速重传与快速恢复：当接收方发现缺少数据段时，连续发送缺少报文的ACK，触发发送方重传

例如：发送1，2，3，4，5 接受方收到1 ，3，4，5 	接收方连续发送三个ACK = 2 。发送方立即重传



#### TCP流量控制

滑动窗口大小：每个TCP报文段包含一个窗口字段，指示发送方可以连续发送多少字节的字段而不用等待确认

接收方窗口大小：通过窗口字段告诉发送方自己可接受的窗口大小

动态调整：根据窗口大小动态调整发送速率

确认机制：接收方定期发送ACK报文，告知发送方已成功接收数据



#### TCP拥塞控制

慢启动：发送方以较小窗口开始发送，每次成功则指数级增长（一般是^2)

拥塞避免：到达阈值后以线性增加方式增加窗口大小

快速重传：在触发连续相同ACK报文后，立即重传未确认的数据包

快速恢复：将慢启动阈值设为当前窗口的一半，将拥塞窗口设为慢启动阈值+已确认但未被重传的数据块的数量



#### TCP三次握手

三次握手影响的首部数据包括四个：序列号、确认应答号、ACK、SYN

第一个报文（客户端->服务端）：**客户端确认服务端是否能接收请求（SYN）**

将**SYN**置1，随机初始化一个序号作为序列号（client_isn）

第二个报文（服务端->客户端）：**服务端确认客户端是否能接收响应（SYN+ACK）**

将**SYN**和**ACK**置1，随机初始化一个序号作为序列号（server_isn），将client_isn + 1填入确认应答号中	

第三个报文（客户端->服务端）：**客户端确认服务端的确认信息（ACK）**

ACK置1，将server_isn + 1 填入确认应答号中，发送后客户端进入establish状态，服务端收到后也进入establish状态

总结：第三次握手可以携带数据，前两次握手不可携带数据



问：TCP三次握手如果变成两次或四次，会有什么后果？

答：

- 如果是两次握手，服务端会在没有确认客户端接收能力的情况下建立连接，容易受到 SYN Flood 攻击，造成资源浪费。
- 如果是四次握手，流程效率降低且逻辑上不必要，因为三次握手已经能确认双方的收发能力。





#### TCP四次挥手

第一个报文：客户端向服务端发送**FIN**位置1的报文（客户端：我不发报文了）

第二个报文：服务端向客户端发送**ACK**应答报文，随后处理剩余数据（服务端：我知道了）

第三个报文：服务端向客户端发送**FIN**报文（服务端：我也不发报文了）

第四个报文：客户端向服务端发送**ACK**报文，服务器接收后进入close状态（客户端：我也知道了）

两个报文最大生存时间（即允许报文丢失一次）后，客户端进入close状态

总结：两个方向都需要一个ACK和FIN报文，若客户端发送三次FIN报文，服务器皆未收到，客户端自动关闭



问：TCP四次挥手如果变成三次或五次，会有什么后果？

答：

- 如果是服务端将ACK报文和FIN报文合并，那么可以只发送三次报文，实际上还是四次挥手。如果最后一个ACK报文不发送，则无法保证连接同步、安全关闭
- 如果是五次挥手，一般表示有一方无法关闭或状态异常，不影响正常关闭，可能会导致连接释放延迟



#### TCP数据最后一小段处理

问：如果TCP发送的数据最后只剩下一小部分，不足以构成一个完整的报文，它会怎么处理？

答：TCP是一个面向字节流的协议，它并不要求每个报文段必须填满MSS（最大报文段长度）。无论这部分的数据大小TCP也会照常发送这部分数据，如果是结束连接前的最后一小段数据，则会与四次挥手中的第一个FIN报文结合，组合成一个报文。



#### Keep-Alive与TCP Keep-Alive	长连接机制

HTTP Keep-Alive由应用层实现，客户端和服务器在完成一个HTTP请求后并不立即关闭连接，保持连接处于打开状态

TCP Keep-Alive由传输层实现，称为TCP保活机制，发送一个报文给对端，测试对端是否存活，收到报文后回复一个ACK数据包

HTTP Keep-Alive的优缺点

优点：

减少TCP重新建立的时间与资源，提高性能与效率

可以在一个连接上同时发多个请求，提升并发性能

多个请求共享同一个连接的头部信息，减少头部信息重复传输

缺点：

占用服务器资源，设置超时时间（浏览器为30-60秒）



#### SYN攻击

原理：攻击者伪造不同IP的SYN报文请求连接，占用服务器半连接队列

解决方法：

增大半连接队列大小

当队列满时，启用cookie，发送报文给客户端，当收到客户端回复后再加入accpet队列



### CDN（内容分发网络）

将内容存储在分布式服务器上，降低用户从服务器获取内容的时间和距离



#### 工作流程

对用户输入的域名进行解析，若网站启用了CDN，则返回离用户最近的CDN节点而不是源服务器IP地址

CDN节点根据服务器的负载和可用性动态的分发到最合适的服务器节点上

CDN会检查是否已经缓存了该资源，若没有，则从源服务器获取资源并缓存到节点中



#### 加速方法

1、就近访问

2、内容缓存

3、前置缓存：根据网站配置，提前将热门内容缓存

4、智能负载均衡：根据服务器负载与可用，智能分发

5、压缩技术

6、并行下载：支持多路复用



### Cookie 和 Session

用于管理用户状态和身份，cookie在用户端，session在服务端



#### Cookie的工作原理

1、服务器在HTTP响应的头部信息"Set-Cookie"标头创建一个cookie，包括名称、过期时间、域名、路径等

2、浏览器接收到"Set-Cookie"标头后，将cookie存储到本地

3、当用户再次访问时将cookie加入HTTP请求头

4、服务端根据cookie内容判断用户状态，提供个性化内容

ps：

服务器可以发送新的"Set-Cookie"标头来更新cookie

cookie可以设置过期时间，会话级（浏览器关闭时失效）、持久性（一段时间后失效）



#### Session工作原理

1、服务器为首次访问的用户创建一个唯一的会话标识符

2、每个会话标识符对应一个会话存储空间，存储用户会话期间的状态和数据

3、服务器为每个会话设置超时时间，过期自动删除

4、用户退出会话自动删除



#### Cookie 和 Session的区别

存储位置：cookie在浏览器，session在服务器

数据容量：cookie容量较小，session容量较大

安全性：cookie可被用户修改，session无法被用户修改

传输方式：cookie在每次HTTP请求中自动发送，session id通过cookie或url传递





#### SSO  单点登录

允许用户一次登录后访问多个应用程序或服务

降低密码重用风险，方便用户体验，简化应用开发

















 
